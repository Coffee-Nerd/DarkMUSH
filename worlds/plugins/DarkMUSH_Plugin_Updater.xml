<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="DarkMUSH_Plugin_Updater"
   author="Asmodeus and Hadar"
   id="15bf0c926513966c26478da0"
   language="Lua"
   purpose="Manage and maintain multiple scripts from GitHub"
   save_state="y"
   date_written="2022-10-24 00:00:00"
   requires="4.00"
   version="3.3"
   >

</plugin>

<include name="constants.lua"/>

<aliases>
     <alias
     script="pmMain"
     match="^pru ?(.*)?$"
     enabled="y"
     regexp="y"
     sequence="100"
     >
     </alias>
     <alias
     script="updatePlugin"
     match="^updatePlugin ([0-9a-zA-Z]+)$"
     enabled="y"
     regexp="y"
     sequence="100"
     >
     </alias>
     <alias
     script="reloadPlugin"
     match="^reloadPlugin ([0-9a-zA-Z]+)$"
     enabled="y"
     regexp="y"
     sequence="100"
     >
     </alias>
     <alias
     script="removePlugin"
     match="^removePlugin ([0-9a-zA-Z]+)$"
     enabled="y"
     regexp="y"
     sequence="100"
     >
     </alias>
     <alias
     script="installPlugin"
     match="^installPlugin ([0-9a-zA-Z]+)$"
     enabled="y"
     regexp="y"
     sequence="100"
     >
     </alias>
     <alias match="^pru help$"
	enabled="y"
	sequence="100"
	send_to="12"
	regexp="y"
	keep_evaluating="y"
	>
	<send>
		PruHelp()
	</send>
     </alias>
</aliases>

<script>
<![CDATA[
require "serialize"
require "tprint"
local json = require("json")
dofile(GetInfo(60) .. "darkwiz_plugin_colors.lua")

local gitHubRaw = "https://raw.githubusercontent.com/Coffee-Nerd/DarkMUSH-Updater/main/github.list"
local rawPluginUrl
pluginlinelength = 0
paddedpluginlinelength = 0
  

function utilprint(str, messageType)

	if messageType == "error" then
          AnsiNote(ColoursToANSI("@x238[@RDE@x202MO@x208N P@x214LU@x220G@x228IN @x220MA@x214NA@x208G@x202E@RR@x238]@W:@w"..str))
     elseif messageType == "script" then
          AnsiNote(ColoursToANSI("@x238@x238[@RDE@x202MO@x208N P@x214LU@x220G@x228IN @x220MA@x214NA@x208G@x202E@RR@x238]@c "..str))
     else
		AnsiNote(ColoursToANSI(str))
	end
	
end

function OnPluginSaveState ()
	SetVariable ("hpmVar", "hpmVar = " .. serialize.save_simple (hpmVar))
	SetVariable ("hpmpastfirstinstall2", "true")
end -- function OnPluginSaveState


function OnPluginInstall ()
     PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
     PLUGIN_NAME   = GetPluginInfo(GetPluginID(), 1)
   	if GetVariable ("enabled") == "false" then
		ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
		check (EnablePlugin(GetPluginID (), false))
		return
	end 
	
	utilprint("Use pru help for help regarding the updater - this notification will look better in the future","script")
  
	OnPluginEnable ()
end

function OnPluginEnable ()
     -- Initialize with empty tables first
     hpmVar = {}
     hpmVar["cache"] = {}
     ghName = nil
     
     -- Then load saved state if it exists (this will overwrite the empty tables)
     if GetVariable ("hpmpastfirstinstall2") == "true" then
		assert (loadstring (GetVariable ("hpmVar") or "")) ()
	end
     
     -- Only initialize cache if it's still empty after loading
     if not hpmVar["cache"] then
          hpmVar["cache"] = {}
     end
     
     makeRawUrl()
     buildCache()    
end

function OnPluginListChanged()
    SaveState()
 end

function string.explode(str, separator, plain)
    assert(type(separator) == "string" and separator ~= "", "Invalid separator (need string of length >= 1)") -- Check if the separator is valid

    local result = {}  -- Table to hold the segments
    local nextIndex = 1  -- The next index where we will insert
    local currentPosition = 1  -- Starting position for each search

    while true do
        local start, stop = str:find(separator, currentPosition, plain)         -- Find the next instance of separator
        
        if not start then break end         -- If no more separators, then break

        if currentPosition ~= start then         -- If there are characters before the separator, add them to result
            result[nextIndex] = str:sub(currentPosition, start - 1)
            nextIndex = nextIndex + 1
        end

        currentPosition = stop + 1         -- Move the current position past this instance of separator
    end

    result[nextIndex] = str:sub(currentPosition)     -- Add the last segment of the string to the result

    return result
end


function onSendActionComplete(success,data)
     if success then
          ghName = data
     else
          return
     end
end

function pmMain(l, m, wc)
     local first, rest = wc[1]:match("(%w+)%s*(.*)")
     
     if first == nil then
          PruHelp()
          return
     end
     
     if first == "check" then
          pmList()
     elseif first == "update" then
          updatePluginThis()
     elseif first == "help" then
          PruHelp()
     end
     
end
    
-- Global variables
build_Len = 0
build_res = 0

function pmList()
    makeRawUrl()
    buildCache()

    build_Len = getPluginCount(rawPluginUrl)
    build_res = 0

   -- utilprint("@x238+---------------------[...]")
    for pluginName, fileUrls in pairs(rawPluginUrl) do
        if type(fileUrls) == "table" and #fileUrls > 0 then
            -- Find the main XML file (first .xml file in the list)
            local mainXmlUrl = nil
            for _, url in ipairs(fileUrls) do
                if url:match("%.xml$") then
                    mainXmlUrl = url
                    break
                end
            end
            
            if mainXmlUrl then
                async_ok, async = pcall(require, "async")
                ghName = async.doAsyncRemoteRequest(mainXmlUrl, buildOutput, "HTTPS")
            end
        end
    end
end

function getPluginCount(pluginTable)
    local count = 0
    for pluginName, fileUrls in pairs(pluginTable) do
        if type(fileUrls) == "table" and #fileUrls > 0 then
            count = count + 1
        end
    end
    return count
end

function buildOutput(retval, page, status, headers, full_status, request_url)
    local pluginId, ghName

    if status == 200 then
        ghName = getName(page, true)
        pluginId = string.match(page, '%s+id="(%w+)"')
    else
        print(request_url)
        utilprint("Cant connect to github", "error")
        return
    end

    build_res = build_res + 1

    renderPluginInfo(build_res, build_Len, ghName, pluginId)

end

-- Create colored hyperlink
function createColoredHyperlink(action, colorString, hint)
    local styles = ColoursToStyles(colorString)  -- Convert Aardwolf color codes to MUSHclient style runs
    
    for _, v in pairs(styles) do                 -- Loop through the styles to create the hyperlink
        local styleToUse = v.bold and 1 or 0     -- Check if 'bold' exists and set style accordingly
        NoteStyle(styleToUse)

        if v.text and v.textcolour then          -- Check all required fields
            local backcolour = 0                 -- Since 'backcolour' is missing, we'll use a default (let's say black: 0)
            
            Hyperlink(
                action,                          -- What happens when you click the link
                v.text,                          -- Displayed text
                hint,                            -- What displays when you hover over the link
                RGBColourToName(v.textcolour),   -- Foreground color
                RGBColourToName(backcolour),     -- Background color (default to black)
                0,
                true
            )
        else
            Note("One of the necessary fields (text, textcolour, backcolour) is missing in the styles table")
        end
    end
end

function simple_utf8_char(code)
    if code < 128 then
        return string.char(code)
    elseif code < 2048 then
        return string.char(192 + math.floor(code / 64), 128 + code % 64)
    elseif code < 65536 then
        return string.char(224 + math.floor(code / 4096), 128 + math.floor(code % 4096 / 64), 128 + code % 64)
    else
       return string.char(240 + math.floor(code / 262144), 128 + math.floor(code % 262144 / 4096), 128 + math.floor(code % 4096 / 64), 128 + code % 64)
    end
end


function displayUnicode(code_point)
    return simple_utf8_char(tonumber(code_point, 16))
end

function unicodeprint(string)
    string = string:gsub("#(%x+)", function(hex)
        return displayUnicode(hex)
    end)
    Simulate(ColoursToANSI(string))
end
function printHorizontalLine(length)
    local line = displayUnicode("2500"):rep(length)
    unicodeprint("@x238│" .. line .. "│")
end

-- Function to print a separator
function printSeparator(length)
    unicodeprint("@x238├" .. displayUnicode("2500"):rep(length - 2) .. "┤\n")
end
-- Default foreground color
local defaultForegroundColor = "238"

function TellUnicodeColours(color_coded_str)
    -- Replace Unicode code points first
    local stringWithUnicode = color_coded_str:gsub("#(%x+)", function(hex)
        return displayUnicode(hex)
    end)

    -- Prepend the default foreground color to the string
    stringWithUnicode = "@x" .. defaultForegroundColor .. stringWithUnicode

    -- Convert Aardwolf color codes to style objects
    local styles = ColoursToStyles(stringWithUnicode, "w", nil)

    -- Loop through the styles and apply them with ColourTell
    for _, style in ipairs(styles) do
        ColourTell(
            RGBColourToName(style.textcolour),
            RGBColourToName(style.backcolour or 0),  -- assuming black background if not specified
            style.text
        )
    end
end


function renderPluginInfo(build_res, build_Len, ghName, pluginId)
    if build_res == 1 then
        unicodeprint("@x238┌" .. displayUnicode("2500"):rep(90) .. "┐")
    else
        printSeparator(92)
    end
    TellUnicodeColours("│ @x238[@R" .. build_res .. "@x238] @x208" .. ghName .. " ")
    pluginlinelength = #ghName + 6
    if IsPluginInstalled(hpmVar["cache"][pluginId]["pluginId"]) then
        local localVersion = tonumber(hpmVar["cache"][pluginId]["localVersion"]) or 0
        local webVersion = tonumber(hpmVar["cache"][pluginId]["webVersion"]) or 0
        if localVersion < webVersion then
            needUpdate = true
            pluginlinelength = pluginlinelength + #tostring(localVersion) + 4 + #tostring(webVersion) + 8 + 10 -- This is for "[Update] "
            elseif localVersion >= webVersion then
            needUpdate = false
            pluginlinelength = pluginlinelength + 9 -- This is for "[Latest] "
        end
      pluginlinelength = pluginlinelength + 9 -- This is for "[Reload] "
      -- Add space for refresh button if plugin has multiple files
      local fileCount = hpmVar["cache"][pluginId]["allFiles"] and #hpmVar["cache"][pluginId]["allFiles"] or 0
      if fileCount > 1 then
        pluginlinelength = pluginlinelength + 15 + #tostring(fileCount) -- This is for "[Refresh all X files] "
      end
      pluginlinelength = pluginlinelength + 9 -- This is for "[Remove] "
      paddedpluginlinelength = string.rep(" ", 90 - pluginlinelength)
      TellUnicodeColours("" .. paddedpluginlinelength .. "")
      if needUpdate then 
        createColoredHyperlink("updatePlugin " .. pluginId, "@x238[@x196U@x202p@x208d@x214a@x220t@x226e @x190P@x154l@x118u@x082g@x047i@x048n@x238]", "Download and Update Plugin")
        TellUnicodeColours(" @x238 (@w" .. hpmVar["cache"][pluginId]["localVersion"] .. "@Y->@G"..webVersion.."@x238) ")
      else 
        TellUnicodeColours("@x238(@x041La@x035te@x029s@x023t@x238) ")
      end
        
      createColoredHyperlink("reloadPlugin " .. pluginId, "@x238[@YR@x220e@x214lo@x220a@Yd@x238] ", "Reload plugin") 
      -- Show refresh button for plugins with multiple files
      local fileCount = hpmVar["cache"][pluginId]["allFiles"] and #hpmVar["cache"][pluginId]["allFiles"] or 0
      if fileCount > 1 then
        createColoredHyperlink("updatePlugin " .. pluginId, "@x238[@x034R@x040e@x046f@x052r@x058e@x064s@x070h@x238] ", "Refresh all " .. fileCount .. " files") 
      end
      createColoredHyperlink("removePlugin " .. pluginId, "@x238[@RRemove@x238] ", "Remove plugin")
      TellUnicodeColours("@x238│")
    else
        pluginlinelength = pluginlinelength + 10 -- This is for "[Install] "
        paddedpluginlinelength = string.rep(" ", 80 - pluginlinelength)
        TellUnicodeColours("" .. paddedpluginlinelength .. "")
        createColoredHyperlink("installPlugin " .. pluginId, "@x208[Install] ", "Install plugin")
        TellUnicodeColours("@x238│")
    end    
  --  TellUnicodeColours("[@YVersion @R" .. hpmVar["cache"][pluginId]["localVersion"] .. "@x238] │")
    print("")
    local purpose = hpmVar["cache"][pluginId]["purpose"]
    local paddedPurpose = purpose .. string.rep(" ", 87 - #purpose)
    TellUnicodeColours("│  @x073" .. paddedPurpose .. " @x238│")
    print("")
    if build_res == build_Len then
        unicodeprint("@x238└" .. displayUnicode("2500"):rep(90) .. "┘@w")
    end
end



function getName(Data, p)
    local name
    if p then
        name = string.upper(string.gsub(string.match(Data, '%s+name="DarkMUSH?_([%w_]+)"'), "_", " "))
    else
        name = string.match(Data, '%s+name="DarkMUSH?_([%w_]+)"')
    end
    return name
end

function loadVariables(wc)
    local script_id = wc[1]
    -- Check if the cache entry exists
    if hpmVar["cache"][script_id] then
        local script_name = hpmVar["cache"][script_id]["localName"]
        local script_url = hpmVar["cache"][script_id]["url"]
        local script_pid = hpmVar["cache"][script_id]["pluginId"]

        return script_id, script_name, script_url, script_pid
    else
        print("Error: Cache entry for script_id not found.")
        return nil
    end
end

function handleAsyncRequest(script_url, script_name)
    local async_ok, async = pcall(require, "async")
    if async_ok then
        local script_rawurl = async.request(script_url, "HTTPS")
        local retval, page, status, headers, full_status = script_rawurl:join()

        if status == 200 then
            local lscript = io.open(script_name, "wb")
            -- Normalize line endings for text files
            if script_name:match("%.xml$") or script_name:match("%.lua$") then
                page = page:gsub("\r\n", "\n"):gsub("\r", "\n")
            end
            lscript:write(page)
            lscript:close()
        end
        return status
    end
    return nil
end

function updateAllPluginFiles(script_id)
    local cache_entry = hpmVar["cache"][script_id]
    if not cache_entry then
        utilprint("No cache entry found for plugin ID: " .. script_id, "error")
        return false
    end
    
    if not cache_entry.allFiles then
        utilprint("No file list found for plugin: " .. (cache_entry.shortName or script_id), "error")
        utilprint("Cache entry exists but allFiles is missing", "error")
        utilprint("Attempting to rebuild file list from rawPluginUrl", "script")
        
        -- Try to rebuild allFiles from rawPluginUrl
        local allFiles = {cache_entry.url}  -- Start with main XML
        if rawPluginUrl then
            for pluginName, fileUrls in pairs(rawPluginUrl) do
                if type(fileUrls) == "table" and #fileUrls > 0 then
                    for _, url in ipairs(fileUrls) do
                        if url == cache_entry.url then
                            allFiles = fileUrls
                            utilprint("Rebuilt file list with " .. #allFiles .. " files", "script")
                            break
                        end
                    end
                end
            end
        end
        cache_entry.allFiles = allFiles
        
        -- Special case for GMCP Mapper - ensure Lua file is included
        if (cache_entry.shortName or ""):upper():find("GMCP") and (cache_entry.shortName or ""):upper():find("MAPPER") then
            local luaFile = "https://raw.githubusercontent.com/Coffee-Nerd/DarkMUSH/main/lua/darkwizmapper.lua"
            local hasLuaFile = false
            for _, file in ipairs(allFiles) do
                if file == luaFile then
                    hasLuaFile = true
                    break
                end
            end
            if not hasLuaFile then
                table.insert(allFiles, luaFile)
                utilprint("Added missing darkwizmapper.lua to file list", "script")
            end
            cache_entry.allFiles = allFiles
        end
    end
    
    local script_directory = GetInfo(60)
    local success_count = 0
    local total_files = #cache_entry.allFiles
    
    -- Handle directory references by downloading as ZIP instead of individual files
    local expandedFiles = {}
    for _, fileUrl in ipairs(cache_entry.allFiles) do
        if fileUrl:match("^%[DIR:(.+)%]$") then
            local dirPath = fileUrl:match("^%[DIR:(.+)%]$")
            utilprint("Found directory reference: " .. dirPath, "script")
            
            -- Try to download the entire directory as ZIP for faster operation
            if dirPath:match("worlds/plugins/images$") then
                utilprint("Attempting to download images directory as ZIP instead of 201+ individual files", "script")
                local zipSuccess = downloadImagesAsZip(dirPath)
                if not zipSuccess then
                    -- ZIP failed, fall back to individual file downloads
                    utilprint("ZIP download failed, falling back to individual file downloads", "script")
                    local dirFiles = fetchDirectoryFiles(dirPath)
                    for _, dirFile in ipairs(dirFiles) do
                        table.insert(expandedFiles, dirFile)
                    end
                end
                -- If ZIP succeeded, don't add individual files to expandedFiles
            else
                -- For other directories, use individual file downloads
                utilprint("Expanding directory: " .. dirPath, "script")
                local dirFiles = fetchDirectoryFiles(dirPath)
                for _, dirFile in ipairs(dirFiles) do
                    table.insert(expandedFiles, dirFile)
                end
            end
        else
            table.insert(expandedFiles, fileUrl)
        end
    end
    
    total_files = #expandedFiles
    utilprint("Updating " .. total_files .. " files for " .. (cache_entry.shortName or script_id) .. " (forcing update of all associated files)", "script")
    
    for _, fileUrl in ipairs(expandedFiles) do
        local fileName = fileUrl:match("/([^/]+)$")
        local localPath
        
        -- Determine the correct local path based on the GitHub URL structure
        if fileName:match("%.xml$") then
            localPath = script_directory .. fileName
        elseif fileUrl:match("/lua/[^/]+%.lua$") then
            -- Lua files from /lua/ directory go to lua/ subdirectory
            local base_directory = script_directory:gsub("worlds[/\\]plugins[/\\]*$", "")
            local lua_directory = base_directory .. "lua/"
            os.execute("mkdir -p \"" .. lua_directory .. "\"")
            localPath = lua_directory .. fileName
            utilprint("Lua file detected, saving to: " .. localPath, "script")
        elseif fileName:match("%.lua$") then
            -- Other lua files go to plugins directory
            localPath = script_directory .. fileName
        elseif fileName:match("%.zip$") and fileName == "images.zip" then
            -- Special handling for pre-built images.zip
            localPath = script_directory .. fileName
            utilprint("Pre-built images ZIP detected, will extract to images directory", "script")
        elseif fileName:match("%.bmp$") or fileName:match("%.png$") or fileName:match("%.jpg$") or fileName:match("%.jpeg$") or fileName:match("%.gif$") then
            local images_directory = script_directory .. "images/"
            os.execute("mkdir -p \"" .. images_directory .. "\"")
            localPath = images_directory .. fileName
            utilprint("Image file detected, saving to: " .. localPath, "script")
        else
            localPath = script_directory .. fileName
        end
        
        utilprint("Downloading: " .. fileName .. " to " .. localPath, "script")
        local status = handleAsyncRequest(fileUrl, localPath)
        if status == 200 then
            success_count = success_count + 1
            utilprint("Successfully downloaded: " .. fileName, "script")
            
            -- If this is the images.zip file, extract it
            if fileName:match("%.zip$") and fileName == "images.zip" then
                utilprint("Extracting images.zip to images directory", "script")
                local images_directory = script_directory .. "images/"
                
                -- Clear and recreate images directory to ensure clean extraction
                utilprint("Clearing existing images directory for clean extraction", "script")
                if os.getenv("OS") and os.getenv("OS"):lower():find("windows") then
                    os.execute("rmdir /S /Q \"" .. images_directory:gsub("/", "\\") .. "\" 2>nul")
                    os.execute("mkdir \"" .. images_directory:gsub("/", "\\") .. "\" 2>nul")
                else
                    os.execute("rm -rf \"" .. images_directory .. "\"")
                    os.execute("mkdir -p \"" .. images_directory .. "\"")
                end
                
                -- Extract ZIP file to images directory (Windows-compatible)
                local extractCommand
                if os.getenv("OS") and os.getenv("OS"):lower():find("windows") then
                    -- Windows: Use PowerShell to extract ZIP, then move files to correct location
                    local tempDir = script_directory .. "temp_extract/"
                    extractCommand = "powershell -Command \"Expand-Archive -Path '" .. localPath .. "' -DestinationPath '" .. tempDir .. "' -Force; Move-Item -Path '" .. tempDir .. "images/*' -Destination '" .. images_directory .. "' -Force; Remove-Item -Path '" .. tempDir .. "' -Recurse -Force\""
                else
                    -- Unix/Linux: Use unzip with correct path handling
                    extractCommand = "cd \"" .. script_directory .. "\" && unzip -o \"" .. localPath .. "\" && mv images/* \"" .. images_directory .. "\" && rmdir images"
                end
                
                utilprint("Extracting with command: " .. extractCommand, "script")
                local extractResult = os.execute(extractCommand)
                
                -- Clean up ZIP file
                os.remove(localPath)
                
                if extractResult == 0 then
                    utilprint("Successfully extracted images.zip to images directory", "script")
                else
                    utilprint("Failed to extract images.zip", "error")
                end
            end
        else
            utilprint("Failed to download: " .. fileName .. " (Status: " .. tostring(status) .. ")", "error")
        end
    end
    
    utilprint("Downloaded " .. success_count .. "/" .. total_files .. " files", "script")
    return success_count == total_files
end

function updatePlugin(name, line, wc)
    local script_id, script_name, script_url, script_pid = loadVariables(wc)
    utilprint("Updating Plugin @G" .. hpmVar["cache"][script_id]["shortName"] .. "@w (all associated files will be refreshed)", "script")
    UnloadPlugin(script_pid)
    
    local success = updateAllPluginFiles(script_id)
    if success then
        utilprint("Plugin @G" .. hpmVar["cache"][script_id]["shortName"] .. "@c Updated with all files! Enjoy!", "script")
        local loadResult = LoadPlugin(script_name)
        if loadResult ~= 0 then
            utilprint("Error loading updated plugin: " .. script_name .. " (Error code: " .. loadResult .. ")", "error")
        else
            utilprint("Updated plugin loaded successfully: " .. script_name, "script")
            -- Force a rebuild of the cache for this specific plugin
            -- This needs to happen after LoadPlugin to get the new version
            DoAfterSpecial(0.5, 'updateSinglePluginCache("' .. script_id .. '")', sendto.script)
        end
    else
        utilprint("Plugin update failed for @R" .. hpmVar["cache"][script_id]["shortName"], "error")
    end
end

function installPlugin(name, line, wc)
    local script_id, script_name, script_url, script_pid = loadVariables(wc)
    utilprint("@x238Installing Plugin @Y" .. hpmVar["cache"][script_id]["shortName"] .. "@w", "script")
    
    local success = updateAllPluginFiles(script_id)
    if success then
        utilprint("@x238Plugin @Y" .. hpmVar["cache"][script_id]["shortName"] .. "@x238 Installed... Enjoy!", "script")
        local loadResult = LoadPlugin(script_name)
        if loadResult ~= 0 then
            utilprint("Error loading plugin: " .. script_name .. " (Error code: " .. loadResult .. ")", "error")
        else
            utilprint("Plugin loaded successfully: " .. script_name, "script")
            -- Update cache after successful load
            DoAfterSpecial(0.5, 'updateSinglePluginCache("' .. script_id .. '")', sendto.script)
        end
    else
        utilprint("Plugin installation failed for @R" .. hpmVar["cache"][script_id]["shortName"], "error")
    end
end
function reloadPlugin(name, line, wc)
    local script_id, script_name, script_url, script_pid = loadVariables(wc)
    utilprint("@x238Currently reloading script: @Y" .. hpmVar["cache"][script_id]["shortName"] .. "@x238 please stand by", "script")
    ReloadPlugin(script_pid)
end

function removePlugin(name, line, wc)
    local script_id, script_name, script_url, script_pid = loadVariables(wc)
    utilprint("Currently Removing script: " .. hpmVar["cache"][script_id]["shortName"] .. "@x238 please stand by")
    UnloadPlugin(script_pid)
    local ok, err = os.remove(script_name)
    if ok then
        utilprint("@RRemoved@x238 script: @Y" .. hpmVar["cache"][script_id]["shortName"] .. "@w", "script")
    else
        utilprint("Was not able to remove @Y" .. hpmVar["cache"][script_id]["shortName"] .. " @R" .. err .. "@w", "error")
    end
end


function makeRawUrl()
     async_ok, async = pcall (require, "async")
     if async_ok then
          makeRawURL = async.request(gitHubRaw, "HTTPS")
          retval, page, status, headers, full_status = makeRawURL:join()
          
          if status == 200 then
               rawPluginUrl = parsePluginList(page)
          end--end 200
     end --end async_ok
     return rawPluginUrl
end

function parsePluginList(content)
    local lines = string.explode(content, "\n")
    local plugins = {}
    local currentPlugin = nil
    local currentFiles = {}
    
    for _, line in ipairs(lines) do
        line = line:match("^%s*(.-)%s*$") -- trim whitespace
        
        if line:match("^%[PLUGIN:(.+)%]$") then
            -- Start of new plugin
            if currentPlugin then
                -- Save previous plugin
                plugins[currentPlugin] = currentFiles
            end
            currentPlugin = line:match("^%[PLUGIN:(.+)%]$")
            currentFiles = {}
        elseif line == "[END]" then
            -- End of current plugin
            if currentPlugin then
                plugins[currentPlugin] = currentFiles
                currentPlugin = nil
                currentFiles = {}
            end
        elseif line:match("^%[DIR:(.+)%]$") then
            -- Directory reference - store the directory path for later expansion
            if currentPlugin then
                local dirPath = line:match("^%[DIR:(.+)%]$")
                table.insert(currentFiles, "[DIR:" .. dirPath .. "]")
            end
        elseif line ~= "" and not line:match("^%[") then
            -- This is a file URL
            if currentPlugin then
                table.insert(currentFiles, line)
            else
                -- Legacy format - single URL without plugin grouping
                -- Extract plugin name from URL for backward compatibility
                local pluginName = line:match("/([^/]+)%.xml$")
                if pluginName then
                    plugins[pluginName] = {line}
                end
            end
        end
    end
    
    -- Handle case where file ends without [END]
    if currentPlugin then
        plugins[currentPlugin] = currentFiles
    end
    
    return plugins
end

function downloadImagesAsZip(dirPath)
    local async_ok, async = pcall(require, "async")
    if not async_ok then
        utilprint("Async module not available for ZIP downloading", "error")
        return false
    end
    
    -- Convert directory path to GitHub ZIP download URL
    local repo, branch, path = dirPath:match("([^/]+/[^/]+)/([^/]+)/(.+)")
    if not repo or not branch or not path then
        utilprint("Invalid directory path format for ZIP download: " .. dirPath, "error")
        return false
    end
    
    -- Create GitHub directory URL for DownGit service
    local githubDirUrl = "https://github.com/" .. repo .. "/tree/" .. branch .. "/" .. path
    
    -- URL encode the GitHub directory URL for DownGit
    local function urlEncode(str)
        return string.gsub(str, "([^%w%-%.%_%~])", function(c)
            return string.format("%%%02X", string.byte(c))
        end)
    end
    
    local encodedGithubUrl = urlEncode(githubDirUrl)
    local downGitUrl = "https://minhaskamal.github.io/DownGit/#/home?url=" .. encodedGithubUrl .. "&rootDirectory=false"
    
    utilprint("Attempting to download directory via DownGit: " .. githubDirUrl, "script")
    utilprint("DownGit URL: " .. downGitUrl, "script")
    
    -- For now, let's try the direct GitHub archive downloads as DownGit may need special handling
    local zipUrls = {
        "https://codeload.github.com/" .. repo .. "/zip/refs/heads/" .. branch,
        "https://github.com/" .. repo .. "/archive/refs/heads/" .. branch .. ".zip"
    }
    
    local zipSuccess = false
    local page = nil
    local status = nil
    
    for i, zipUrl in ipairs(zipUrls) do
        utilprint("Attempting ZIP download " .. i .. "/" .. #zipUrls .. " from: " .. zipUrl, "script")
        local request = async.request(zipUrl, "HTTPS")
        local retval, tempPage, tempStatus, headers, full_status = request:join()
        
        if tempStatus == 200 and tempStatus ~= "ssl" then
            page = tempPage
            status = tempStatus
            zipSuccess = true
            utilprint("ZIP download successful from URL " .. i, "script")
            break
        else
            utilprint("ZIP URL " .. i .. " failed (Status: " .. tostring(tempStatus) .. ")", "script")
        end
    end
    
    if not zipSuccess then
        utilprint("All ZIP download attempts failed, falling back to individual files", "script")
        return false
    end
    
    -- Save ZIP file temporarily
    local script_directory = GetInfo(60)
    local tempZipPath = script_directory .. "temp_images.zip"
    local zipFile = io.open(tempZipPath, "wb")
    if not zipFile then
        utilprint("Failed to create temporary ZIP file", "error")
        return false
    end
    zipFile:write(page)
    zipFile:close()
    
    utilprint("Downloaded ZIP file, extracting images...", "script")
    
    -- Extract only the images directory from the ZIP
    local images_directory = script_directory .. "images/"
    os.execute("mkdir -p \"" .. images_directory .. "\"")
    
    -- Use system unzip to extract - this will work on most systems
    local extractCommand = "cd \"" .. script_directory .. "\" && unzip -j -o \"" .. tempZipPath .. "\" \"*/" .. path .. "/*\" -d \"images/\""
    local extractResult = os.execute(extractCommand)
    
    -- Clean up temporary ZIP file
    os.remove(tempZipPath)
    
    if extractResult == 0 then
        utilprint("Successfully extracted images directory from ZIP", "script")
        return true
    else
        utilprint("Failed to extract ZIP file", "error")
        return false
    end
end

function fetchDirectoryFiles(dirPath)
    local async_ok, async = pcall(require, "async")
    if not async_ok then
        utilprint("Async module not available for directory fetching", "error")
        return {}
    end
    
    -- Convert directory path to GitHub API URL
    -- Expected format: "Coffee-Nerd/DarkMUSH/main/worlds/plugins/images"
    local repo, branch, path = dirPath:match("([^/]+/[^/]+)/([^/]+)/(.+)")
    if not repo or not branch or not path then
        utilprint("Invalid directory path format: " .. dirPath, "error")
        return {}
    end
    
    local apiUrl = "https://api.github.com/repos/" .. repo .. "/contents/" .. path .. "?ref=" .. branch
    local request = async.request(apiUrl, "HTTPS")
    local retval, page, status, headers, full_status = request:join()
    
    if status ~= 200 then
        utilprint("Failed to fetch directory: " .. dirPath .. " (Status: " .. status .. ")", "error")
        return {}
    end
    
    local json = require("json")
    local success, dirContents = pcall(json.decode, page)
    if not success then
        utilprint("Failed to parse directory JSON for: " .. dirPath, "error")
        return {}
    end
    
    local fileUrls = {}
    for _, item in ipairs(dirContents) do
        if item.type == "file" and item.download_url then
            table.insert(fileUrls, item.download_url)
        end
    end
    
    utilprint("Found " .. #fileUrls .. " files in directory: " .. dirPath, "script")
    return fileUrls
end

function raw_get(retval, page, status, headers, full_status, request_url)
     if status == 200 then
          print(page)
     end
end

function tablelength(T)
  local count = 0
  for i,v in pairs(T) do 
     if type(v) == "table" and #v > 0 then
          count = count + 1
     elseif type(v) == "string" and v ~= "" then
          count = count + 1
     end
  end
  return count
end

function buildCache()
    cache_Len = getPluginCount(rawPluginUrl)
    cache_res = 0
    
    -- Store plugin file mappings for later use in cache building
    if not hpmVar then hpmVar = {} end
    if not hpmVar["pluginFiles"] then hpmVar["pluginFiles"] = {} end
    
    for pluginName, fileUrls in pairs(rawPluginUrl) do
        if type(fileUrls) == "table" and #fileUrls > 0 then
            -- Find the main XML file for cache building
            local mainXmlUrl = nil
            for _, url in ipairs(fileUrls) do
                if url:match("%.xml$") then
                    mainXmlUrl = url
                    break
                end
            end
            
            if mainXmlUrl then
                -- Store the file list mapped by the main XML URL
                hpmVar["pluginFiles"][mainXmlUrl] = fileUrls
            end
        end
    end
    
    local async_ok, async = pcall(require, "async")
    if async_ok then
        if rawPluginUrl == nil then
            utilprint("Please make sure the URL is properly filled out", "error")
            return
        end
        
        for pluginName, fileUrls in pairs(rawPluginUrl) do
            if type(fileUrls) == "table" and #fileUrls > 0 then
                -- Find the main XML file for cache building
                local mainXmlUrl = nil
                for _, url in ipairs(fileUrls) do
                    if url:match("%.xml$") then
                        mainXmlUrl = url
                        break
                    end
                end
                
                if mainXmlUrl then
                    async.doAsyncRemoteRequest(mainXmlUrl, raw_get_cache, "HTTPS")
                end
            end
        end
    else
        utilprint("Something went wrong with async in building cache", "error")
    end
end

function updateSinglePluginCache(script_id)
    -- Update the cache for a single plugin after it's been reloaded
    if not hpmVar or not hpmVar["cache"] or not hpmVar["cache"][script_id] then
        return
    end
    
    local cache_entry = hpmVar["cache"][script_id]
    local pluginId = cache_entry.pluginId
    
    -- Debug: Check if plugin is actually loaded
    if not IsPluginInstalled(pluginId) then
        utilprint("Plugin " .. cache_entry.shortName .. " is not installed! Cannot update cache.", "error")
        return
    end
    
    -- Get the updated local version from the now-loaded plugin
    local newLocalVersion = GetPluginInfo(pluginId, 19)
    utilprint("Debug: Plugin ID: " .. pluginId .. ", Version from GetPluginInfo: " .. tostring(newLocalVersion), "script")
    
    -- Also try to read the version directly from the file
    local script_directory = GetInfo(60)
    local xmlPath = script_directory .. cache_entry.rawname .. ".xml"
    local file = io.open(xmlPath, "r")
    if file then
        local content = file:read("*a")
        file:close()
        local fileVersion = content:match('version="(%d+%.%d+)"')
        utilprint("Debug: Version in file " .. xmlPath .. ": " .. tostring(fileVersion), "script")
        
        -- Use file version if GetPluginInfo is returning stale data
        if fileVersion and fileVersion ~= newLocalVersion then
            utilprint("Warning: GetPluginInfo returned " .. tostring(newLocalVersion) .. " but file has " .. fileVersion, "script")
            newLocalVersion = fileVersion
        end
    end
    
    if newLocalVersion then
        hpmVar["cache"][script_id]["localVersion"] = newLocalVersion
        SaveState()
        utilprint("Cache updated: " .. cache_entry.shortName .. " local version is now " .. newLocalVersion, "script")
    end
end

function raw_get_cache(retval, page, status, headers, full_status, request_url)
    local webName, rawName, webVersion, pluginId, localVersion, localName
    local script_directory = GetInfo(60)
    if status == 200 then
        webName = getName(page, false)
        rawName = string.match(page, '%s+name="([a-zA-Z0-9_]+)"')
        webVersion = string.match(page, '  version="(%d+%.%d+)"')
        pluginId = string.match(page, '%s+id="(%w+)"')
        purpose = string.match(page, '%s+purpose="([^"]+)"')
        localVersion = GetPluginInfo(pluginId, 19)
        
        -- Use actual filename from URL instead of constructing from plugin name
        local actualFileName = request_url:match("/([^/]+)$")
        localName = script_directory .. actualFileName
        
        -- Get all files associated with this plugin from our stored mapping
        local allFiles = {}
        if hpmVar and hpmVar["pluginFiles"] and hpmVar["pluginFiles"][request_url] then
            allFiles = hpmVar["pluginFiles"][request_url]
        else
            -- Fallback: just the main XML file, but also search rawPluginUrl
            allFiles = {request_url}
            if rawPluginUrl then
                for pluginName, fileUrls in pairs(rawPluginUrl) do
                    if type(fileUrls) == "table" and #fileUrls > 0 then
                        for _, url in ipairs(fileUrls) do
                            if url == request_url then
                                allFiles = fileUrls
                                utilprint("Found " .. #allFiles .. " files for plugin from rawPluginUrl (including directory references)", "script")
                                break
                            end
                        end
                    end
                end
            end
        end
        
    else
        utilprint("Can't connect to GitHub", "error")
        return
    end
    
    cache_res = cache_res + 1
    
    hpmVar["cache"][pluginId] = {
        shortName = webName,
        rawname = rawName,
        webVersion = webVersion,
        pluginId = pluginId,
        localVersion = localVersion,
        localName = localName,
        url = request_url,
        allFiles = allFiles,
        purpose = purpose
    }
end


function updatePluginThis()
     raw = "https://raw.githubusercontent.com/Coffee-Nerd/DarkMUSH/main/worlds/plugins/DarkMUSH_Plugin_Updater.xml"
     async_ok, async = pcall (require, "async")
     if async_ok then
          plugin_page = async.doAsyncRemoteRequest(raw, Raw_Update, "HTTPS")
     else
          utilprint("Error on updating","error")
     end
end

function Raw_Update(retval, page, status, headers, full_status, request_url)
        if status == 200 then
            raw_version = tonumber(string.match(page, '%s%s+version="(%d+%.?%d+)"'))
        end

        if tonumber(raw_version) == tonumber(PLUGIN_VERSION) then
            utilprint("@Y"..PLUGIN_NAME .. "@x238 is up to date!","script")
        elseif tonumber(raw_version) > tonumber(PLUGIN_VERSION) then
            utilprint("Updating from version @R"..PLUGIN_VERSION.."@x238 to @R"..raw_version.."@x238 Please stand by.","script")
            local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
            file:write(page)
            file:close()
            if "" == GetAlphaOption("script_prefix") then
                SetAlphaOption("script_prefix", "\\\\\\")
            end
            Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
            utilprint("Updating is complete, Have a muddish day!","script")
        elseif tonumber(raw_version) < tonumber(PLUGIN_VERSION) then
          utilprint("Your development is too quick!","error")
        end
        raw_version = nil
    end -- end Update code

function PruHelp()
utilprint("@x238+---------------------@x238[@RDE@x202MO@x208N P@x214LU@x220G@x228IN @x220MA@x214NA@x208G@x202E@RR @WVer @Y"..GetPluginInfo (GetPluginID (), 19).."@x238]------------------+")
utilprint("@x238| @x214pru help                @x110- @x214Displays this helpfile @x238                    |")
utilprint("@x238| @x208pru check               @x110- @x208Checks to see if there is any updates @x238     |")
utilprint("@x238| @x214pru update              @x110- @x214Checks for updates on this script@x238          |")
utilprint("@x238+----------------------------------------------------------------------+")
end

]]>
</script> 

</muclient>
